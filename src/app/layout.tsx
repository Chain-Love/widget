import type { Metadata } from 'next';
import { HydrationBoundary, dehydrate } from '@tanstack/react-query';

import { inter, manrope } from './fonts';
import './globals.css';
import { getQueryClient } from '@/service/get-query-client';
import { configFetchOptions } from '@/service/configApi';
import { headers } from 'next/headers';
import { Providers } from '@/providers';
import { Suspense } from 'react';
import PageLoading from '@/components/ui/page-loading';
import { Toaster } from '@/components/ui/shadcn/sonner';
import Script from 'next/script';

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const headersList = headers();
  const host = headersList.get('host');
  const origin = `http://${host}`;

  const queryClient = getQueryClient();
  await queryClient.prefetchQuery(configFetchOptions(origin));

  return (
    <html
      lang='en'
      suppressHydrationWarning
      className={`${inter.variable} ${manrope.variable}`}
    >
      <body>
        <Providers>
          <HydrationBoundary state={dehydrate(queryClient)}>
            <div id='cl-widget-root' className='flex min-h-dvh flex-col'>
              <Suspense fallback={<PageLoading />}>{children}</Suspense>
              <Toaster />
            </div>
          </HydrationBoundary>

          {/* Marketo-like: @webframe.ready + @webframe.resize { size: { height } } */}
          <Script
            id='cl-webframe-resize-marketo-style'
            strategy='afterInteractive'
            dangerouslySetInnerHTML={{
              __html: `
(function () {
  const gitbookWebFrame = window.parent;
  const ROOT_ID = 'cl-widget-root';
  let cachedSize;

  function sendAction(payload) {
    if (!gitbookWebFrame) {
      console.warn('[chainlove-widget] parent window is not available');
      return;
    }

    try {
      console.info('[chainlove-widget] sendAction', payload);
      gitbookWebFrame.postMessage({ action: payload }, '*');
    } catch (error) {
      console.error('[chainlove-widget] error in postMessage', error);
    }
  }

  /**
   * Recalculate the size of the root element and send @webframe.resize
   * if the size changed.
   */
  function recalculateSize() {
  const el = document.getElementById(ROOT_ID);

  if (!el) {
    console.warn("[chainlove-widget] missing element with id '" + ROOT_ID + "'");
    return;
  }

  const rawHeight = el.offsetHeight;
  const rawWidth = el.offsetWidth;

  if (!rawHeight || rawHeight <= 0) {
    console.warn('[chainlove-widget] invalid offsetHeight', rawHeight);
    return;
  }

  // Add a small buffer to account for iframe chrome.
  const height =
    typeof rawHeight === 'number' ? rawHeight + 2 : rawHeight;

  // If rawWidth is 0 for some reason, we simply skip aspectRatio.
  const aspectRatio =
    rawWidth && rawWidth > 0 ? rawWidth / height : undefined;

  const size = { height, aspectRatio };

  if (
    cachedSize &&
    cachedSize.height === size.height &&
    cachedSize.aspectRatio === size.aspectRatio
  ) {
    // Do not send a resize event if nothing changed.
    return;
  }

  cachedSize = size;
  console.info('[chainlove-widget] recalculateSize', size);

  sendAction({
    action: '@webframe.resize',
    size,
  });
}

  function init() {
    console.info('[chainlove-widget] init');

    // Notify GitBook that the iframe content is ready.
    sendAction({ action: '@webframe.ready' });

    // Give React a short delay to finish rendering nested content,
    // then measure the initial size.
    setTimeout(recalculateSize, 200);

    const target =
      document.getElementById(ROOT_ID) ||
      document.body ||
      document.documentElement;

    if (!target) {
      console.warn('[chainlove-widget] no target element for MutationObserver');
      return;
    }

    if ('MutationObserver' in window) {
      console.info('[chainlove-widget] attaching MutationObserver on #' + ROOT_ID);

      const observer = new MutationObserver(() => {
        recalculateSize();
      });

      observer.observe(target, {
        attributes: true,
        childList: true,
        subtree: true,
      });

      window.addEventListener('beforeunload', () => {
        try {
          observer.disconnect();
        } catch (error) {
          // ignore
        }
      });
    } else {
      console.info('[chainlove-widget] MutationObserver not available, fallback to window.resize');
      window.addEventListener('resize', () => {
        recalculateSize();
      });
    }
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    init();
  } else {
    window.addEventListener('DOMContentLoaded', init, { once: true });
  }
})();`,
            }}
          />
        </Providers>
      </body>
    </html>
  );
}
