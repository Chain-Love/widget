import type { Metadata } from 'next';
import { HydrationBoundary, dehydrate } from '@tanstack/react-query';

import { inter, manrope } from './fonts';
import './globals.css';
import { getQueryClient } from '@/service/get-query-client';
import { configFetchOptions } from '@/service/configApi';
import { headers } from 'next/headers';
import { Providers } from '@/providers';
import { Suspense } from 'react';
import PageLoading from '@/components/ui/page-loading';
import { Toaster } from '@/components/ui/shadcn/sonner';
import Script from 'next/script';

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const headersList = headers();
  const host = headersList.get('host');
  const origin = `http://${host}`;

  const queryClient = getQueryClient();
  await queryClient.prefetchQuery(configFetchOptions(origin));

  return (
    <html
      lang='en'
      suppressHydrationWarning
      className={`${inter.variable} ${manrope.variable}`}
    >
      <body>
        <Providers>
          <HydrationBoundary state={dehydrate(queryClient)}>
            <div className='flex min-h-dvh flex-col'>
              <Suspense fallback={<PageLoading />}>{children}</Suspense>

              <Toaster />
            </div>
          </HydrationBoundary>

          {/* Variant 3: aggressive polling-based resize + multiple sends */}
          <Script
            id='webframe-resize-variant-3'
            strategy='afterInteractive'
            dangerouslySetInnerHTML={{
              __html: `
(function () {
  function computeAspectRatio() {
    var docEl = document.documentElement;
    var body = document.body || docEl;
    if (!docEl || !body) {
      return 1;
    }

    var height = Math.max(
      body.scrollHeight,
      docEl.scrollHeight,
      body.offsetHeight,
      docEl.offsetHeight,
      body.clientHeight,
      docEl.clientHeight
    );

    var width =
      docEl.clientWidth ||
      window.innerWidth ||
      body.clientWidth ||
      1;

    if (!height || height <= 0) return 1;
    var aspectRatio = width / height;
    console.log('[Widget][Variant3] computeAspectRatio()', { width, height, aspectRatio });
    return aspectRatio;
  }

  function sendReady() {
    try {
      console.log('[Widget][Variant3] sending @webframe.ready');
      window.parent.postMessage({ action: '@webframe.ready' }, '*');
    } catch (e) {
      console.error('[Widget][Variant3] error sending @webframe.ready', e);
    }
  }

  function sendResize(aspectRatio) {
    var payload = {
      action: '@webframe.resize',
      aspectRatio: aspectRatio,
      maxHeight: 980,
      maxWidth: 980,
    };
    try {
      console.log('[Widget][Variant3] sending @webframe.resize', payload);
      window.parent.postMessage(payload, '*');
    } catch (e) {
      console.error('[Widget][Variant3] error sending @webframe.resize', e);
    }
  }

  function init() {
    sendReady();

    var lastAspect = 0;
    var tick = function () {
      var aspectRatio = computeAspectRatio();
      if (!aspectRatio || Math.abs(aspectRatio - lastAspect) < 0.001) {
        return;
      }
      lastAspect = aspectRatio;

      sendResize(aspectRatio);
      setTimeout(function () { sendResize(aspectRatio); }, 120);
      setTimeout(function () { sendResize(aspectRatio); }, 300);
    };

    setTimeout(tick, 200);

    var intervalId = setInterval(tick, 500);

    window.addEventListener('beforeunload', function () {
      clearInterval(intervalId);
    });
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    init();
  } else {
    window.addEventListener('DOMContentLoaded', init, { once: true });
  }
})();`,
            }}
          />
        </Providers>
      </body>
    </html>
  );
}
